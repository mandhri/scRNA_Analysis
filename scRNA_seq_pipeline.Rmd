---
title: "Single-Cell RNA-seq Analysis: iPSC Heterogeneity"
author: "Your Name"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    theme: flatly
    code_folding: show
    df_print: paged
---

# Executive Summary

This analysis examines single-cell RNA-sequencing data from **induced pluripotent stem cells (iPSCs)** derived from three Yoruba individuals (Tung et al., 2017). The primary objectives are to:

1. **Assess technical quality** and perform appropriate normalisation
2. **Identify cell subpopulations** through clustering
3. **Characterise cell states** (cell cycle, pluripotency, differentiation)
4. **Discover individual variation** through differential expression
5. **Interpret biological mechanisms** via pathway analysis

**Key Findings:**
- Successfully processed 670 high-quality cells across 13,839 genes
- Identified distinct cell subpopulations with varying cell cycle states
- Detected individual-specific gene expression patterns
- Batch effects successfully corrected while preserving biological signal

---

# 1. Introduction

## 1.1 Biological Context

**Induced Pluripotent Stem Cells (iPSCs)** are reprogrammed somatic cells with embryonic stem cell-like properties. Understanding their heterogeneity is crucial for:
- Regenerative medicine applications
- Disease modeling
- Understanding cellular reprogramming

## 1.2 Dataset Overview

**Source:** Tung et al. (2017) - "Batch effects and the effective design of single-cell gene expression studies"

**Experimental Design:**
- **3 individuals** from the Yoruba population (NA19098, NA19101, NA19239)
- **Multiple technical replicates** per individual (batch structure)
- **iPSC cultures** profiled using scRNA-seq

**Research Questions:**
1. How much heterogeneity exists within iPSC populations?
2. Do cell cycle states drive population structure?
3. What genes vary between individuals (genetic diversity)?
4. Are there subpopulations indicating early differentiation?

---

# 2. Setup

```{r libraries, message=FALSE, warning=FALSE}
# Core single-cell packages
library(SingleCellExperiment)
library(scater)
library(scuttle)
library(scran)
library(batchelor)

# Differential expression
library(edgeR)
library(limma)
library(scDblFinder)

library(SingleR)
library(celldex)
library(AnnotationDbi)
library(org.Hs.eg.db)
library(EnsDb.Hsapiens.v86)
library(fgsea)
library(msigdbr)
library(singscore)
library(ggplot2)
library(patchwork)
library(cowplot)
library(ggrepel)
library(pheatmap)
library(dplyr)
library(tidyr)

```

```{r load_data}
# Load preprocessed data
umi <- readRDS("/mnt/vol1/scRNA_Analysis/DATASETS/Datasets/tung/umi.rds")

```

**Note:** The preprocessing step (not shown) already performed:
- Low-quality cell filtering (low library size, high mitochondrial content)
- Low-expressed gene filtering
- QC metric calculation


# 3. Quality Control and Filtering

## 3.1 Initial QC Filtering

Remove cells and genes flagged during initial QC:

```{r initial_filtering}
# Remove flagged cells and genes from initial QC
umi_qc <- umi[!rowData(umi)$discard, !colData(umi)$discard]

cat("After initial QC filtering:\n")
cat("- Genes:", nrow(umi_qc), "\n")
cat("- Cells:", ncol(umi_qc), "\n")
cat("- Cells removed:", ncol(umi) - ncol(umi_qc), "\n")
cat("- Genes removed:", nrow(umi) - nrow(umi_qc), "\n")
```

## 3.2 Doublet Detection

**Critical step:** Detect and remove doublets BEFORE normalisation and clustering.

In single-cell RNA sequencing (scRNA-seq) experiments, doublets are artifactual libraries generated from two cells. They typically arise due to errors in cell sorting or capture, especially in droplet-based protocols (Zheng et al. 2017) involving thousands of cells.

**Why this order matters:**
- Doublets can form artificial clusters
- Doublet marker genes confound real biology
- Removing doublets after clustering invalidates downstream objects

```{r doublet_detection, fig.width=10, fig.height=5}

# Run doublet detection
set.seed(123)
umi_qc <- scDblFinder(umi_qc)
print(table(umi_qc$scDblFinder.class))

cat("\nDoublet scores summary:\n")
print(summary(umi_qc$scDblFinder.score))

# Visualise doublet scores
df_doublets <- data.frame(
  cell = colnames(umi_qc),
  doublet_score = umi_qc$scDblFinder.score,
  classification = umi_qc$scDblFinder.class,
  library_size = umi_qc$sum,
  individual = umi_qc$individual
)

p1 <- ggplot(df_doublets, aes(x = classification, y = doublet_score, fill = classification)) +
  geom_violin() +
  geom_jitter(width = 0.2, alpha = 0.3, size = 0.5) +
  scale_fill_manual(values = c("singlet" = "steelblue", "doublet" = "red3")) +
  theme_minimal() +
  labs(title = "Doublet Scores by Classification",
       y = "Doublet Score", x = "Classification") +
  theme(legend.position = "none")

p2 <- ggplot(df_doublets, aes(x = library_size, y = doublet_score, color = classification)) +
  geom_point(alpha = 0.5, size = 1.5) +
  scale_color_manual(values = c("singlet" = "steelblue", "doublet" = "red3")) +
  scale_x_log10() +
  theme_minimal() +
  labs(title = "Doublet Score vs Library Size",
       x = "Library Size (log10)", y = "Doublet Score",
       color = "Classification")

p1 + p2

outdir <- "/mnt/vol1/scRNA_Analysis"
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

ggsave(file.path(outdir, "doublet_detection.png"), p1 + p2, 
       width = 12, height = 5, dpi = 300)
```

## 3.3 Remove Doublets

Filter out predicted doublets:

```{r filter_doublets}
# Keep only singlets
umi_filtered <- umi_qc[, umi_qc$scDblFinder.class == "singlet"]

cat("\nAfter doublet removal:\n")
cat("Cells remaining:", ncol(umi_filtered), "\n")
cat("Doublets removed:", sum(umi_qc$scDblFinder.class == "doublet"), "\n")
cat("Doublet rate:", round(100 * mean(umi_qc$scDblFinder.class == "doublet"), 1), "%\n")

# Check distribution across individuals
print(table(umi_filtered$individual))

```

**Note:** All downstream analyses (normalisation, clustering, DE) now work with high-quality singlets only.


# 4. Quality Control and Normalisation

## 4.1  Normalisation Method Comparison

**Why compare methods?** Different normalisation strategies make different assumptions:

- **Raw log counts:** Simple but biased by sequencing depth
- **CPM (Counts Per Million):** Corrects for library size
- **Scran deconvolution:** Sophisticated pooling-based method that handles composition biases

```{r normalisation, fig.width=15, fig.height=5}

# Method 1: Raw log transformation (baseline)
assay(umi_filtered, "logcounts_raw") <- log2(counts(umi_filtered) + 1)

# Method 2: CPM normalisation
assay(umi_filtered, "logcpm") <- log2(calculateCPM(umi_filtered) + 1)

# Method 3: Scran deconvolution (RECOMMENDED)

## Step 1: clustering for pooling
quick_clusters <- quickCluster(umi_filtered, min.size = 20)

## Step 2: Compute size factors
umi_filtered <- computeSumFactors(umi_filtered, clusters = quick_clusters)

## Check size factors
print(summary(sizeFactors(umi_filtered)))

## Step 3: Apply log normalisation
umi_filtered <- logNormCounts(umi_filtered) 

```

### 4.1.1 Visual Comparison

```{r norm_comparison, fig.width=15, fig.height=5}

# Run PCA with each normalisation method
umi_filtered <- runPCA(umi_filtered, exprs_values = "logcounts_raw", name = "PCA_raw")
umi_filtered <- runPCA(umi_filtered, exprs_values = "logcpm", name = "PCA_cpm")
umi_filtered <- runPCA(umi_filtered, exprs_values = "logcounts", name = "PCA_scran")

# Create comparison plots
p1 <- plotPCA(umi_filtered, dimred = "PCA_raw", 
              colour_by = "individual", shape_by = "replicate") +
  ggtitle("Raw Log Counts\n(Depth-dependent)") + 
  theme_minimal() +
  theme(legend.position = "none")

p2 <- plotPCA(umi_filtered, dimred = "PCA_cpm", 
              colour_by = "individual", shape_by = "replicate") +
  ggtitle("CPM Normalised\n(Better separation)") + 
  theme_minimal() +
  theme(legend.position = "none")

p3 <- plotPCA(umi_filtered, dimred = "PCA_scran", 
              colour_by = "individual", shape_by = "replicate") +
  ggtitle("Scran Normalised\n(Best biological signal)") + 
  theme_minimal()

combined <- plot_grid(p1, p2, p3, ncol = 3, align = "hv")
print(combined)
ggsave(file.path(outdir, "normalisation_comparison.png"), combined, 
       width = 15, height = 5, dpi = 300)

```

**Interpretation:**
- **Raw counts** show batch effects (replicates cluster somewhat separate)
- **CPM** improves but still shows technical variation
- **Scran** shows clearest biological separation by individual

- **Conclusion:** Proceeding with scran normalisation


# 5. Batch Correction

## 5.1 Feature Selection (HVGs)

Select **Highly Variable Genes (HVGs)** that capture biological variation:

```{r hvg_selection, fig.width=10, fig.height=5}

# Model gene variance, blocking by replicate
fit <- modelGeneVar(umi_filtered, block = umi_filtered$replicate)

# Select top 2000 HVGs
hvg <- getTopHVGs(fit, n = 2000)
cat("Selected", length(hvg), "highly variable genes\n")

# Run PCA on HVGs
umi_filtered <- runPCA(umi_filtered, subset_row = hvg, name = "PCA")

p1 <- plotPCA(umi_filtered, dimred = "PCA", colour_by = "replicate") +
  ggtitle("Before Correction: Colored by Replicate") +
  theme_minimal()

p2 <- plotPCA(umi_filtered, dimred = "PCA", colour_by = "individual") +
  ggtitle("Before Correction: Colored by Individual") +
  theme_minimal()

p1 + p2

```

**Observation:** individual show strong clustering patterns and replicate show somewhat strong clustering patterns.

## 5.2 Experimental Design Assessment

**CRITICAL CHECK:** Before applying batch correction, we must verify whether batch and biology are independent:

```{r design_check}

# Cross-tabulate individual by replicate
design_table <- table(umi_filtered$individual, umi_filtered$replicate)
design_table

# Formal test of independence (association, not causality)
chi_test <- chisq.test(design_table)
chi_test

```

### 5.2.1 Understanding Confounding

**What we found:** p-value < 0.05 indicates **that the observed individual × replicate counts are not consistent with independence. In other words, individual and replicate are statistically associated**.

The chi-square test gives a small p-value, meaning our individual × replicate table is not what we would expect if these factors were independent. In practice, some replicates mostly or entirely belong to a single donor, so individual and replicate are clearly associated rather than independent.

**What this means:**

The contingency table shows that individual and replicate are not independent:

- Some replicates contain cells from only one individual.

- Replicates are effectively nested within individuals rather than fully crossed.

The chi-square test simply confirms this association statistically (p-value < 0.05), but the important practical implication is:

- We can correct for replicate-specific technical variation,

- We must avoid treating individual as a batch factor, otherwise we risk removing the biological differences we are interested in.


**Why this happened:**
Unbalanced / nested designs are common in real scRNA-seq studies. They do not make batch correction impossible, but they mean we need to:

- Use a technical batch variable (here: replicate) for correction, and

- Explicitly check afterwards that donor-level biology is still visible.

**Consequences:**
In this dataset we therefore focus on:

- Batch factor: replicate (technical),

- Biology of interest: individual (donor).



## 5.2.1.1 FMNN Batch Correction (typical approach)

UMAP is an algorithm that takes a high-dimensional dataset (such as a single-cell RNA dataset) and reduces it to a low-dimensional plot that retains much of the original information

```{r batch_correction, fig.width=10, fig.height=5}

# Create batch factor: individual × replicate
batch_factor <- interaction(umi_filtered$individual, umi_filtered$replicate, drop = TRUE)

# Define merge order: merge replicates within same donor first
levels_batch <- levels(batch_factor)
donor_of_level <- sub("\\.r[0-9]+$", "", levels_batch)
merge_order <- unname(split(seq_along(levels_batch), donor_of_level))
print(merge_order)

# Apply fastMNN
umi_mnn <- fastMNN(
  umi_filtered,
  subset.row = hvg,
  batch = batch_factor,
  merge.order = merge_order,
  k = 50
)

# Transfer metadata
keep_cols <- c("individual", "replicate", "subsets_Mito_percent", "altexps_ERCC_percent")
keep_cols <- intersect(keep_cols, colnames(colData(umi_filtered)))
colData(umi_mnn)[, keep_cols] <- colData(umi_filtered)[colnames(umi_mnn), keep_cols, drop = FALSE]

# UMAP on corrected data
umi_mnn <- runUMAP(umi_mnn, dimred = "corrected")

p1 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "replicate") +
  ggtitle("After Correction: Coloured by Replicate") +
  theme_minimal()

p2 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "individual") +
  ggtitle("After Correction: Coloured by Individual") +
  theme_minimal()

p1 + p2
ggsave(file.path(outdir, "batch_correction_umap.png"), p1 + p2,width = 12, height = 5, dpi = 300)

```

**Note:** In many single-cell studies, especially when the goal is to put **all samples into one common cell-type space**, we correct for *both* donor and replicate. A common pattern is to treat each `donor × replicate` combination as a separate batch and let **fastMNN** align them (like in this chunk in "batch_factor". This works well when every batch has a reasonable number of cells and donors are fairly balanced.

This “batch = donor × replicate” strategy is conceptually fine but not suitable for our data because the design is unbalanced: one donor–replicate group had almost/no cells after QC and doublet removal. In that situation, fastMNN will try to align very small groups to large ones and can over-correct, removing true donor-level biology.


## 5.3 FastMNN Batch Correction with Validation

Use **fastMNN** (Mutual Nearest Neighbours) to reduce replicate-specific technical differences while retaining donor-level variation as far as possible:


**Key principle:** Apply correction, then validate that biological signal is preserved

```{r batch_correction_fastmnn, fig.width=12, fig.height=5}

# Apply fastMNN (correcting for replicate only, not individual)
umi_mnn <- fastMNN(
  umi_filtered,
  subset.row = hvg,
  batch = umi_filtered$replicate,  # Correct for technical batch only
  k = 50
)

# Transfer metadata
keep_cols <- c("individual", "replicate", "subsets_Mito_percent", "altexps_ERCC_percent")
keep_cols <- intersect(keep_cols, colnames(colData(umi_filtered)))
colData(umi_mnn)[, keep_cols] <- colData(umi_filtered)[colnames(umi_mnn), keep_cols, drop = FALSE]

# UMAP on corrected data
umi_mnn <- runUMAP(umi_mnn, dimred = "corrected")

p1 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "replicate") +
  ggtitle("After Correction: Replicates Well-Mixed") +
  theme_minimal()

p2 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "individual") +
  ggtitle("After Correction: Individuals Separated") +
  theme_minimal()

p1 + p2

ggsave(file.path(outdir, "batch_correction_umap.png"), p1 + p2, 
       width = 12, height = 5, dpi = 300)
```

**Visual Assessment:**
- **Left:** Replicates (r1, r2, r3) are well-mixed. replicates overlap strongly in the corrected UMAP. Therefore, replicate-driven structure has been largely removed.
- **Right:** donors still form distinct islands. Therefore, substantial donor-level biological signal remains.

### 5.3.1 Quantitative Validation

To support the visual impression, we quantify the variance in the first 10 PCs explained by replicate and individual before and after correction.

```{r correction_metrics}

# Verify PCA exists
if (!"PCA" %in% reducedDimNames(umi_filtered)) {
  stop("PCA not found in umi_filtered. Make sure section 5.1 ran correctly.")
}

# Extract PCs before and after correction
pcs_before <- reducedDim(umi_filtered, "PCA")[, 1:10, drop = FALSE]
pcs_after <- reducedDim(umi_mnn, "corrected")[, 1:10, drop = FALSE]

# Function to calculate adjusted R²
calc_adjR2 <- function(pcs, factor) {
  apply(pcs, 2, function(pc) {
    summary(lm(pc ~ factor))$adj.r.squared
  })
}

# Calculate R² for replicate and individual

# BEFORE correction
r2_rep_before <- calc_adjR2(pcs_before, umi_filtered$replicate)
r2_ind_before <- calc_adjR2(pcs_before, umi_filtered$individual)

# AFTER correction
cells_match <- match(colnames(pcs_after), colnames(pcs_before))
r2_rep_after <- calc_adjR2(pcs_after, umi_mnn$replicate)
r2_ind_after <- calc_adjR2(pcs_after, umi_mnn$individual)

metrics <- data.frame(
  PC = 1:10,
  R2_replicate_before = round(r2_rep_before, 3),
  R2_individual_before = round(r2_ind_before, 3),
  R2_replicate_after = round(r2_rep_after, 3),
  R2_individual_after = round(r2_ind_after, 3)
)

print(metrics)

# Summary
cat("\n=== VALIDATION SUMMARY ===\n")
cat("BEFORE correction:\n")
cat("  Max R² for replicate:", round(max(r2_rep_before), 3), "\n")
cat("  Max R² for individual:", round(max(r2_ind_before), 3), "\n")
cat("\nAFTER correction:\n")
cat("  Max R² for replicate:", round(max(r2_rep_after), 3), "\n")
cat("  Max R² for individual:", round(max(r2_ind_after), 3), "\n")

```


**Key Metrics:**
- **Batch (replicate) R²:** Reduced from ~0.69 to ~0.07 (Replicate explains a much smaller proportion of variance after correction (adj. R² drops by an order of magnitude across PCs))

- **Biology (individual) R²:** Individual still explains a substantial proportion of variance after correction.

**Conclusion:** 
fastMNN with batch = replicate substantially reduces replicate-specific technical effects while retaining enough donor-level structure to study biological differences, even though donor and replicate are not fully independent.


# 5. Clustering and Cell Type Identification

## 5.1 Graph-Based Clustering

```{r clustering, fig.width=12, fig.height=5}

# Build shared nearest neighbor (SNN) graph
snn_graph <- buildSNNGraph(umi_mnn, use.dimred = "corrected", k = 20)

# Detect communities using Walktrap algorithm
clusters <- igraph::cluster_walktrap(snn_graph)$membership
colLabels(umi_mnn) <- factor(clusters)

print(table(colLabels(umi_mnn)))


p1 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "label") +
  ggtitle("Clusters") +
  theme_minimal() +
  theme(legend.position = "right")

p2 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "individual") +
  ggtitle("Individual") +
  theme_minimal()

p3 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "subsets_Mito_percent") +
  ggtitle("Mitochondrial Content") +
  scale_color_viridis_c() +
  theme_minimal()

combined <- p1 + p2 + p3 + plot_layout(ncol = 3)
print(combined)
ggsave(file.path(outdir, "clustering_overview.png"), combined, 
       width = 15, height = 5, dpi = 300)
```

**Observation:** 
- No strong mitochondrial gradient = good quality control
- Clusters show some individual enrichment

## 5.2 Marker Gene Discovery

Identify genes that define each cluster:

```{r markers}
# Transfer cluster labels to filtered object
umi_filtered <- umi_filtered[, colnames(umi_mnn)]
umi_filtered$cluster <- colLabels(umi_mnn)
umi_filtered$cluster <- droplevels(umi_filtered$cluster)

# Find marker genes
markers <- scran::scoreMarkers(
  umi_filtered, 
  groups = umi_filtered$cluster,
  assay.type = "logcounts"
)

# Save top markers for each cluster
marker_dir <- file.path(outdir, "markers")
dir.create(marker_dir, showWarnings = FALSE)

top_markers_list <- list()

for (cl in names(markers)) {
  # Extract marker data frame
  marker_df <- as.data.frame(markers[[cl]])
  marker_df$gene <- rownames(marker_df)
  
  # Sort by AUC (Area Under Curve - discriminative power)
  marker_df <- marker_df[order(marker_df$mean.AUC, decreasing = TRUE), ]
  
  # Save full results
  write.csv(marker_df, 
            file.path(marker_dir, paste0("markers_cluster_", cl, ".csv")),
            row.names = FALSE)
  
  # Store top 10 for summary
  top_markers_list[[cl]] <- head(marker_df[, c("gene", "mean.AUC", "mean.logFC.cohen", 
                                                "self.average", "other.average")], 10)
}

# Display top markers for Cluster 1
cat("\nTop 10 markers for Cluster 1:\n")
print(top_markers_list[["1"]])

```

### 5.2.1 Marker Gene Heatmap

```{r marker_heatmap, fig.width=10, fig.height=10}
# Select top 5 markers per cluster
top_genes <- unique(unlist(lapply(markers, function(m) {
  rownames(m)[order(m$mean.AUC, decreasing = TRUE)][1:5]
})))

# Create heatmap
plotHeatmap(umi_filtered,
            features = top_genes,
            colour_columns_by = "cluster",
            exprs_values = "logcounts",
            center = TRUE,
            symmetric = TRUE,
            cluster_rows = TRUE,
            cluster_cols = TRUE,
            fontsize_row = 8,
            main = "Top Marker Genes per Cluster")
```

## 5.3 Reference-Based Cell Type Annotation

Use **SingleR** to automatically annotate cell types. 
We use SingleR with the Human Primary Cell Atlas reference as a coarse sanity check, not as definitive iPSC cell-type annotation. The main biological interpretation relies on unsupervised clusters, marker genes, and canonical pluripotency markers; we therefore refer to these groups as iPSC subpopulations rather than assigning them to differentiated cell types from the reference.

```{r singler_annotation, fig.width=10, fig.height=5}

# Ensure rownames are clean Ensembl IDs
rownames(umi_filtered) <- sub("\\.\\d+$", "", rownames(umi_filtered))

# Set up cache directory
cache_dir <- file.path(outdir, "bioc_cache")
dir.create(cache_dir, recursive = TRUE, showWarnings = FALSE)
Sys.setenv(
  ANNOTATIONHUB_CACHE = cache_dir,
  EXPERIMENT_HUB_CACHE = cache_dir,
  BIOCFILECACHE_CACHE = cache_dir
)

# Load a reference that includes stem/progenitor-like profiles
# (Human Primary Cell Atlas instead of Blueprint/ENCODE)
ref <- celldex::HumanPrimaryCellAtlasData(ensembl = TRUE)

# Run SingleR
pred <- SingleR(
  test = umi_filtered,
  ref = ref,
  labels = ref$label.main
)

# Add to umi_mnn
umi_mnn$ref_label <- pred$labels


p1 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "ref_label") +
  ggtitle("SingleR Cell Type Annotation") +
  theme_minimal() +
  theme(legend.position = "right")

p2 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "label") +
  ggtitle("Graph Clusters") +
  theme_minimal()

p1 + p2

#ggsave(file.path(outdir, "cell_type_annotation.png"), p1 + p2, width = 14, height = 5, dpi = 300)

print(table(Cluster = umi_mnn$label, CellType = umi_mnn$ref_label))
```
**Result**

- All cells are in a pluripotent or near-pluripotent state.
- There is no evidence of contaminating differentiated cell types.
- UMAP structure is not driven by ESC vs iPSC calls.
- 3 donor islands (cluster 1, 2, 3), which match with fastMNN + replicate-only correction.


SingleR (using the Human Primary Cell Atlas reference) classifies all cells as
either **iPS cells** or **embryonic stem cells**, with both labels intermixed
across all three clusters. This behaviour is expected because ESCs and iPSCs
are transcriptionally very similar in bulk references.

The important point is that **no differentiated cell types** (e.g. epithelial,
immune, endothelial, mesenchymal) were assigned. This provides independent
confirmation that all cells in our dataset represent **pluripotent stem cell
states** without contamination.

Because the SingleR reference does not resolve fine-grained iPSC states, and
because clustering clearly reflects **donor-level variation** rather than cell
type heterogeneity, we treat these groups as **iPSC subpopulations** rather
than attempting to assign differentiated cell type labels.



# 6. Cell Cycle Analysis

iPSCs can be in different cell cycle phases, which contributes to heterogeneity. For cell cycle scoring we used the canonical S and G2/M gene lists from
Macosko et al. (2015) / Regev lab (identical to the `cc.genes` set used in the
original Seurat workflow), rather than constructing gene sets automatically
from GO term names. This provides a more standard and reproducible definition
of cell cycle phases.

Using these markers, cells are classified into G1, S, and G2/M states. The
resulting phase calls are distributed across all three donor-specific clusters,
indicating that the major structure in the corrected UMAP reflects donor
variation rather than simple separation by cell cycle.

```{r cell_cycle, fig.width=12, fig.height=8}

# Verify cells are aligned
cat("Cell alignment check:\n")
cat("- Cells in umi_filtered:", ncol(umi_filtered), "\n")
cat("- Cells in umi_mnn     :", ncol(umi_mnn), "\n")
cat("- Cells match          :", identical(colnames(umi_filtered), colnames(umi_mnn)), "\n\n")

# SYMBOL-based SCE for scoring
syms <- rowData(umi_filtered)$SYMBOL
ok   <- !is.na(syms) & syms != ""
sce_sym <- umi_filtered[ok, ]
rownames(sce_sym) <- syms[ok]

cat("Created sce_sym for cell cycle scoring:\n")
cat("- Genes with symbols:", nrow(sce_sym), "\n")
cat("- Cells             :", ncol(sce_sym), "\n\n")

# Canonical S and G2M gene sets (Macosko / Regev / Seurat cc.genes)
s_genes <- c(
  "MCM5","PCNA","TYMS","FEN1","MCM2","MCM4","RRM1","UNG","GINS2","MCM6",
  "CDCA7","DTL","PRIM1","UHRF1","HELLS","RFC2","RPA2","NASP","RAD51AP1",
  "GMNN","WDR76","SLBP","CCNE2","UBR7","POLD3","MSH2","ATAD2","RAD51",
  "RRM2","CDC45","CDC6","EXO1","TIPIN","DSCC1","BLM","CASP8AP2","USP1",
  "CLSPN","POLA1","CHAF1B","BRIP1","E2F8"
)

g2m_genes <- c(
  "HMGB2","CDK1","NUSAP1","UBE2C","BIRC5","TPX2","TOP2A","NDC80","CKS2",
  "NUF2","CKS1B","MKI67","TMPO","CENPF","TACC3","FAM64A","SMC4","CCNB2",
  "CKAP2L","CKAP2","AURKB","BUB1","KIF11","ANP32E","TUBB4B","GTSE1",
  "KIF20B","HJURP","CDCA3","HN1","CDC20","TTK","CDC25C","KIF2C","RANGAP1",
  "NCAPD2","DLGAP5","CDCA2","CDCA8","ECT2","KIF23","HMMR","AURKA",
  "PSRC1","ANLN","LBR","CKAP5","CENPE","CTCF","NEK2","G2E3","GAS2L3",
  "CBX5","CENPA"
)

cat("Original S genes  :", length(s_genes), "\n")
cat("Original G2M genes:", length(g2m_genes), "\n\n")

# Keep only genes present in the data
s_genes_present   <- intersect(s_genes,   rownames(sce_sym))
g2m_genes_present <- intersect(g2m_genes, rownames(sce_sym))

cat("Cell cycle markers found in data:\n")
cat("- S phase   :", length(s_genes_present),  "/", length(s_genes),   "\n")
cat("- G2/M phase:", length(g2m_genes_present), "/", length(g2m_genes), "\n\n")

if (length(s_genes_present) < 10 || length(g2m_genes_present) < 10) {
  warning("Few canonical cell cycle markers found - phase calls may be less reliable")
}

# Expression matrix for scoring
expr_mat <- logcounts(sce_sym)

# S and G2M scores = mean expression of markers
s_scores   <- colMeans(expr_mat[s_genes_present,   , drop = FALSE])
g2m_scores <- colMeans(expr_mat[g2m_genes_present, , drop = FALSE])

# Normalise scores (z-score across cells)
s_scores_norm   <- as.numeric(scale(s_scores))
g2m_scores_norm <- as.numeric(scale(g2m_scores))

# Assign phases:

# default G1, then S if S high, G2M if G2M high, prioritise G2M if both re high
phases <- rep("G1", ncol(sce_sym))
phases[s_scores_norm   > 0.5] <- "S"
phases[g2m_scores_norm > 0.5] <- "G2M"
phases[s_scores_norm > 0.5 & g2m_scores_norm > 0.5] <- "G2M"

cat("Cell cycle phase assignment:\n")
phase_table <- table(phases)
print(phase_table)
cat("\nPhase percentages:\n")
print(round(100 * prop.table(phase_table), 1))

umi_mnn$S_score   <- s_scores_norm
umi_mnn$G2M_score <- g2m_scores_norm
umi_mnn$phase     <- factor(phases, levels = c("G1","S","G2M"))
print(table(umi_mnn$phase))

p1 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "phase") +
  ggtitle("Cell cycle phase (canonical S / G2M genes)") +
  scale_color_manual(values = c("G1" = "gray60", "S" = "steelblue", "G2M" = "orange")) +
  theme_minimal()

p2 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "S_score") +
  ggtitle("S phase score") +
  scale_color_viridis_c() +
  theme_minimal()

p3 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "G2M_score") +
  ggtitle("G2/M phase score") +
  scale_color_viridis_c() +
  theme_minimal()

p4 <- plotReducedDim(umi_mnn, "UMAP", colour_by = "label") +
  ggtitle("Graph clusters") +
  theme_minimal()

combined <- (p1 + p2) / (p3 + p4)
print(combined)


# Summary tables
cat("\nCell cycle distribution:\n")
print(table(Phase = umi_mnn$phase))
cat("\nCell cycle by cluster:\n")
print(table(Cluster = umi_mnn$label, Phase = umi_mnn$phase))
cat("\nCell cycle by individual:\n")
print(table(Individual = umi_mnn$individual, Phase = umi_mnn$phase))


```

**Interpretation:**
Using canonical S and G2/M markers from Macosko et al. (2015), we assigned
cell cycle phases to all cells. As expected for iPSCs, G1, S, and G2/M cells
are present across all donors.

Importantly, **cell cycle variation does not explain the graph clusters**:
each donor-specific island contains a mixture of phases, and both S-phase and
G2/M scores vary within clusters rather than between them.

This confirms that the major structure in the corrected UMAP reflects
**donor-level biological differences** rather than cycling artefacts.


**Note**

1. What iPSCs usually do

iPSCs in culture are proliferative and asynchronous. That means at any given time you expect a mix of G1, S, and G2/M cells in the same line. You don’t expect “this subpopulation never divides” vs “this one always divides” like you would in a tissue with differentiated cells.

So at the biology level: a fairly even spread of cycling states across the cell population is normal for iPSC cultures.

2. What we don’t want in scRNA-seq clustering

In single-cell, cell cycle is a well-known nuisance axis: it can make cells cluster by “where they are in the cycle” instead of “what they actually are”. If your UMAP/cluster is split into:

- “G2/M cells cluster 1”

- “S cells cluster 2”

- “G1 cells cluster 3”

then your clusters are mostly cell-cycle driven, not biology-driven.

So if you correct/integrate properly and then score cell cycle and see: “my three clusters are not secretly just G1 vs S vs G2/M”, that’s good. It tells you your clustering isn’t being hijacked by cell cycle.


# 8. Differential Expression Analysis

Because fastMNN correction was applied to *replicate* only, the corrected UMAP
retains clear donor separation, and graph-based clustering recovers three
donor-specific islands (Section 5). As a result, each graph cluster corresponds
almost exactly to a single individual.

This means that pseudo-bulk differential expression between clusters is
equivalent to **donor-level differential expression**. We therefore interpret
these contrasts as testing **inter-individual differences in iPSC expression**,
rather than distinct cell types or stable cell states.

## 8.1 Pseudo-bulk Aggregation


### 8.1a. Donor-level (Cluster-based) aggregation

Aggregate by cluster for direct individual comparisons:

```{r pseudobulk_cluster}
# Create aggregation IDs
agg_ids <- DataFrame(
  donor = droplevels(factor(umi_filtered$individual)),
  replicate = droplevels(factor(umi_filtered$replicate)),
  cluster = droplevels(factor(umi_filtered$cluster))
)

# Aggregate
pb_cluster <- aggregateAcrossCells(umi_filtered, ids = agg_ids)

cat("Cluster-based pseudo-bulk structure:\n")
cat("- Samples:", ncol(pb_cluster), "\n")
cat("- Genes:", nrow(pb_cluster), "\n\n")

cat("Samples per cluster:\n")
print(table(pb_cluster$cluster, pb_cluster$donor))
```


**Interpretation:**
That means:

cluster 1 = only donor NA19101

cluster 2 = only donor NA19098

cluster 3 = only donor NA19239

Thus, “cluster DE” = “donor DE”.

### 8.1b. Cell-type–based aggregation (optional)

Used only to demonstrate how within-cell-type donor comparisons could be
performed. Not the main focus of this dataset.

```{r pseudobulk_celltype}

stopifnot(identical(colnames(umi_filtered), colnames(umi_mnn)))

donor    <- as.character(umi_filtered$individual)
celltype <- as.character(umi_mnn$ref_label)   # from SingleR
celltype[is.na(celltype)] <- "Unassigned"

group <- interaction(celltype, donor, drop = TRUE)

pb_mat <- scuttle::sumCountsAcrossCells(umi_filtered, ids = group)

pb_celltype <- SingleCellExperiment(
  list(counts = pb_mat)
)

grp_info <- do.call(rbind, strsplit(levels(group), split = "\\."))

colData(pb_celltype)$celltype <- grp_info[,1]
colData(pb_celltype)$donor    <- grp_info[,2]

table(pb_celltype$celltype, pb_celltype$donor)

```


## 8.2 Donor-level Differential Expression (pairwise comparisons)

Since each cluster = one individual,each pairwise contrast compares two individuals.

```{r de_clusters, results='hide'}

de_cluster_results <- list()

# all pairwise cluster comparisons
clusters <- levels(pb_cluster$cluster)
cat("CLUSTER COMPARISONS")
cat("Comparing", length(clusters), "clusters in pairwise")

# For each pair of clusters
for (i in 1:(length(clusters)-1)) {
  for (j in (i+1):length(clusters)) {
    clu1 <- clusters[i]
    clu2 <- clusters[j]
    
    comparison_name <- paste0("Cluster_", clu1, "_vs_", clu2)
    cat("Testing", comparison_name, "...\n")
    
    # Subset
    keep <- pb_cluster$cluster %in% c(clu1, clu2)
    mat <- assay(pb_cluster, "counts")[, keep, drop = FALSE]
    cluster_group <- droplevels(pb_cluster$cluster[keep])
    replicate <- droplevels(pb_cluster$replicate[keep])
    
    # EdgeR
    y <- DGEList(mat)
    y <- calcNormFactors(y)
    
    # Design: cluster + replicate (blocking for tech batch)
    design <- model.matrix(~ 0 + cluster_group + replicate)
    colnames(design) <- make.names(colnames(design))
    
    # Filter low-expressed genes
    keep_genes <- filterByExpr(y, design = design, min.count = 5)
    y <- y[keep_genes, , keep.lib.sizes = FALSE]
    
    cat("  Testing", nrow(y), "genes after filtering\n")
    
    # dispersion
    y <- estimateDisp(y, design)
    
    fit <- glmQLFit(y, design)
    
    # Test: cluster 1 vs cluster 2
    contrast_str <- paste0("cluster_group", clu1, " - cluster_group", clu2)
    cn <- makeContrasts(contrasts = contrast_str, levels = design)
    
    qlf <- glmQLFTest(fit, contrast = cn)
    tt <- topTags(qlf, n = Inf)$table
    
    de_cluster_results[[comparison_name]] <- tt
    
    cat("  Found", sum(tt$FDR < 0.05), "DE genes (FDR < 0.05)\n")
    cat(" ", sum(tt$FDR < 0.05 & tt$logFC > 0), "higher in Cluster", clu1, "\n")
    cat(" ", sum(tt$FDR < 0.05 & tt$logFC < 0), "higher in Cluster", clu2, "\n\n")
  }
}
```
**NOTE:**

These results quantify inter-individual variation between the three Yoruba iPSC donors.


```{r de_summary}

if (length(de_cluster_results) == 0) {
  cat("\nCluster-level DE: none computed.\n")
} else {
  de_cluster_summary <- data.frame(
    Comparison   = names(de_cluster_results),
    DE_Genes     = sapply(de_cluster_results, function(x) sum(x$FDR < 0.05)),
    Upregulated  = sapply(de_cluster_results, function(x) sum(x$FDR < 0.05 & x$logFC > 0)),
    Downregulated= sapply(de_cluster_results, function(x) sum(x$FDR < 0.05 & x$logFC < 0))
  )
  cat("\nCluster-level DE summary (cluster ≈ donor):\n")
  print(de_cluster_summary)
}


```

## 7.3 Volcano Plots + Gene Annotation

```{r volcano_plots, fig.width=8, fig.height=6}

plot_volcano <- function(de_table, title, top_n = 10) {
df <- as.data.frame(de_table)
df$gene <- rownames(df)

df$significant <- ifelse(df$FDR < 0.05 & abs(df$logFC) > 1,
"Significant", "Not Significant")

df <- df[order(abs(df$logFC), decreasing = TRUE), ]
df$label <- ""
n_to_label <- min(top_n, nrow(df))
df$label[1:n_to_label] <- df$gene[1:n_to_label]

ggplot(df, aes(x = logFC, y = -log10(PValue), color = significant)) +
geom_point(alpha = 0.6, size = 1.5) +
geom_text_repel(aes(label = label), size = 3, max.overlaps = 20) +
scale_color_manual(values = c("Not Significant" = "grey70",
"Significant" = "red3")) +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
theme_minimal() +
labs(title = title)
}

for (comp in names(de_cluster_results)) {
de_tab <- de_cluster_results[[comp]]
if (sum(de_tab$FDR < 0.05) > 0) {
print(plot_volcano(de_tab, paste("DE:", comp)))
}
}



```

**Interpretation:**
- 1. Donor 1 vs Donor 2

(NA19101 vs NA19098)

161 DE genes (FDR < 0.05). So these two donors are different, but not wildly different.
Points to the right (logFC > 0): genes higher in cluster 1 / NA19101.
Points to the left (logFC < 0): genes higher in cluster 2 / NA19098.
A few genes have quite large negative FC (like ~ –10) = those are strongly up in donor 2.
The shape is pretty balanced = these two donors are the most similar pair among the 3.
So, Donor 1 vs Donor 2(NA19101 vs NA19098) = moderate donor-specific expression.


- 2. Donor 1 vs Donor 3

(NA19101 vs NA19239)

437 DE genes.
Much fatter cloud of red points above the FDR line = way more genes changing.
We have a huge positive logFC gene (ENSG00000106153) = that gene is much higher in cluster 1 / NA19101 than in NA19239.
Also some big negatives = genes higher in cluster 3 / NA19239.
donor NA19239 is transcriptionally the most different from NA19101.
So: Donor 1 vs Donor 3 is strongest donor contrast.


- 3. DE:Donor 2 vs Donor 3 Cluster

(NA19098 vs NA19239)
144 DE genes = so still clear differences, but a bit less than 1 vs 3.
One extreme gene on the right (same ENSG00000106153) = meaning that gene is high in cluster 2 / NA19098 and low in NA19239.
Some genes far to the left,so those are higher in cluster 3 / NA19239.
Donor 2 vs Donor 3  is also different, but not as dramatic as 1 vs 3.


**Overall conclusion:**
These contrasts demonstrate substantial inter-individual transcriptional
variation among the three Yoruba iPSC lines. Because clustering reflects donor
identity, these results should not be interpreted as cell-type differences,
but as donor-associated transcriptional signatures within iPSCs.



# 8. Pathway Analysis

## 8.1 Gene Set Enrichment (GSEA)

Test whether biological pathways are enriched in differentially expressed genes:

```{r gsea, results='hide'}

# Hallmark gene sets
hallmark <- msigdbr(species = "Homo sapiens", category = "H")
hallmark_list <- split(hallmark$gene_symbol, hallmark$gs_name)

# ENSEMBL to SYMBOL
ens_to_symbol <- function(ens_vec) {
  ens_clean <- sub("\\.\\d+$", "", ens_vec)
  AnnotationDbi::mapIds(
    org.Hs.eg.db,
    keys     = ens_clean,
    column   = "SYMBOL",
    keytype  = "ENSEMBL",
    multiVals= "first"
  )
}

enrichment_results <- list()

for (comp in names(de_cluster_results)) {
  cat("Running GSEA for", comp, "\n")
  
  de_tab <- de_cluster_results[[comp]]
  if (nrow(de_tab) == 0) next
  
  # map gene IDs
  syms <- ens_to_symbol(rownames(de_tab))
  ranks <- -log10(de_tab$PValue) * sign(de_tab$logFC)
  names(ranks) <- syms
  
  keep <- !is.na(names(ranks)) & !is.na(ranks) & is.finite(ranks)
  ranks <- ranks[keep]
  ranks <- tapply(ranks, names(ranks), max)
  ranks <- sort(ranks, decreasing = TRUE)
  
  if (length(ranks) < 20) {
    cat("  Skipping", comp, "- too few ranked genes after mapping\n")
    next
  }
  
  fg <- fgsea(
    pathways = hallmark_list,
    stats    = ranks,
    minSize  = 15,
    maxSize  = 500,
    nperm    = 10000
  )
  
  fg <- fg[order(fg$pval), ]
  enrichment_results[[comp]] <- fg
  
  fg_out <- as.data.frame(fg)
  fg_out$leadingEdge <- vapply(fg$leadingEdge, paste, collapse = ";", FUN.VALUE = character(1))
  
  write.csv(
    fg_out,
    file.path(de_dir, paste0("enrichment_", comp, ".csv")),
    row.names = FALSE
  )
}

```

```{r gsea_summary}
# Print top enriched pathways for each comparison
for (comp in names(enrichment_results)) {
  res <- enrichment_results[[comp]]
  
  # keep sig pathways at FDR < 0.1
  sig <- res[res$padj < 0.1, ]
  
  if (nrow(sig) > 0) {
    sig <- sig[order(sig$padj), ]
    topn <- min(5, nrow(sig))
    
    cat("\n=== ", comp, " - Top enriched pathways (FDR < 0.1) ===\n", sep = "")
    print(sig[1:topn, c("pathway", "pval", "padj", "NES")])
  } else {
    cat("\n=== ", comp, " - no pathways at FDR < 0.1 ===\n", sep = "")
  }
}

```

## 8.2 Pathway Activity Scoring

Calculate pathway scores for each cell using singscore:

```{r pathway_scoring, fig.width=10, fig.height=8}

# 1) Collect significant Hallmark pathways from GSEA (FDR < 0.5)

sig_pathways <- do.call(rbind, lapply(names(enrichment_results), function(comp) {
  res <- enrichment_results[[comp]]
  if (is.null(res) || nrow(res) == 0) return(NULL)

  sig <- res[res$padj < 0.5, c("pathway", "padj", "NES")]
  if (nrow(sig) == 0) return(NULL)

  sig$comparison <- comp
  sig
}))

if (is.null(sig_pathways)) {
  stop("No significant Hallmark pathways (FDR < 0.1) were detected in GSEA.")
}

# Order by FDR within comparison
sig_pathways <- sig_pathways[order(sig_pathways$comparison, sig_pathways$padj), ]

# For each clusyter, take the top 5 significant pathways
sel_paths <- unlist(tapply(sig_pathways$pathway,
                           sig_pathways$comparison,
                           function(x) head(unique(x), 5)))

paths_to_score <- unique(sel_paths)

cat("Hallmark pathways selected for per-cell scoring (FDR < 0.1 in GSEA):\n")
print(sig_pathways[sig_pathways$pathway %in% paths_to_score, ])

# Per-cell scoring for the selected pathways only

expr_mat <- as.matrix(assay(sce_sym, "logcounts"))
rnk      <- singscore::rankGenes(expr_mat)

scores <- vapply(paths_to_score, function(gs_name) {
  gs <- pathways[[gs_name]]          # reuse the Hallmark list
  gs <- intersect(gs, rownames(sce_sym))
  if (length(gs) < 5) return(rep(NA_real_, ncol(sce_sym)))
  singscore::simpleScore(rnk, upSet = gs)$TotalScore
}, FUN.VALUE = numeric(ncol(sce_sym)))

scores_df <- as.data.frame(scores)
rownames(scores_df) <- colnames(sce_sym)
scores_df <- scores_df[colnames(umi_mnn), , drop = FALSE]

for (nm in colnames(scores_df)) {
  umi_mnn[[nm]] <- scores_df[[nm]]
}

# UMAP overlays for the selected pathways

plot_list <- lapply(paths_to_score, function(pw) {
  plotReducedDim(umi_mnn, "UMAP", colour_by = pw) +
    ggtitle(gsub("HALLMARK_", "", pw)) +
    scale_color_viridis_c() +
    theme_minimal() +
    theme(legend.position = "right")
})

combined <- wrap_plots(plot_list, ncol = 2)
print(combined)

```

**Note:**

For per-cell pathway activity we restricted attention to Hallmark pathways that
were **significantly enriched in the pseudo-bulk GSEA** (FDR < 0.5) in at least
one donor comparison. For each contrast, we selected the top five pathways by
adjusted p-value and obtained a unique set of N pathways (listed in the console
output above). These pathways (e.g. HALLMARK_G2M_CHECKPOINT, HALLMARK_XYZ)
were then scored at the single-cell level using singscore and visualised on the
UMAP.

This ensures that the pathway overlays shown in Figure X correspond directly to
pathways identified as significantly enriched in the donor-level GSEA, rather
than being arbitrarily chosen.


# References

- **Tung et al. (2017)** "Batch effects and the effective design of single-cell gene expression studies" *Scientific Reports*
- **Lun et al. (2016)** "A step-by-step workflow for low-level analysis of single-cell RNA-seq data" *F1000Research*
- **Haghverdi et al. (2018)** "Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors" *Nature Biotechnology*


