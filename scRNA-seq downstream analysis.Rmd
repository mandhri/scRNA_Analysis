---
title: "Advanced scRNA-seq Downstream Analysis"
output: html_document
date: "2025-02-25"
---

Overview
This analysis extends our preprocessing workflow to demonstrate advanced single-cell genomics capabilities, focusing on:

- Normalisation method comparison and selection.
- Cell clustering and subpopulation identification
- Differential expression analysis
- Biological pathway insights
- Disease mechanism discovery

# Load libraries

```{r LIBRARIES, message=FALSE, warning=FALSE}
library(readxl)
library(tidyverse)
library(metafor)
library(ggplot2)
library(dplyr)
library(readr)
library(patchwork)
library(cowplot)
library(SingleCellExperiment)
library(AnnotationDbi)
library(org.Hs.eg.db)
library(EnsDb.Hsapiens.v86)
library(scater)
library(scran)

```

# Load your preprocessed data

```{r load_data}

umi <- readRDS("/mnt/vol1/scRNA_playground/DATASETS/Datasets/tung/umi.rds")


```

# PART 1: Quality Control and Normalisation Strategy

## Initial Filtering

First, we remove low-quality cells and genes identified during preprocessing:

assays(umi)$counts holding the expression matrix (genes x cells).
colData(umi) storing metadata for each cell.

so this SingleCellExperiment object(umi) had 19027 genes (rows) and 864 cells (columns) and now filtered to 13847 genes (rows) and 670 cells (columns) 

```{r clning_further}

# Remove discarded cells and genes
umi_filtered <- umi[!rowData(umi)$discard, !colData(umi)$discard]
print(paste("Filtered to", nrow(umi_filtered), "genes and", ncol(umi_filtered), "cells"))
```


## Normalisation method comparison

Different normalisation approaches can dramatically affect downstream analysis. We will compare three methods:

- Raw log-transformed counts - Simple but depth-dependent
- CPM normalisation - Library size correction
- Scran deconvolution - Sophisticated bias correction


```{r}

# Method 1: Simple log transformation (as baseline)
assay(umi_filtered, "logcounts_raw") <- log2(counts(umi_filtered) + 1)

# Method 2: CPM (Counts Per Million) normalisation
assay(umi_filtered, "logcpm") <- log2(calculateCPM(umi_filtered) + 1)

# Method 3: Scran deconvolution normalisation (recommended)
set.seed(123)
quick_clusters <- quickCluster(umi_filtered, min.size=20)
umi_filtered <- computeSumFactors(umi_filtered, clusters=quick_clusters)

# Check size factors are well-behaved
cat("Size factor summary:")
print(summary(sizeFactors(umi_filtered)))

# Apply log normalisation using size factors
umi_filtered <- logNormCounts(umi_filtered)  # Creates "logcounts" assay

```

###  Visual comparison of normalisation methods


Let's compare how each method affects the data structure using PCA:

```{r norm, message=FALSE, warning=FALSE}

# Run PCA with different normalisation methods
umi_filtered <- runPCA(umi_filtered, exprs_values="logcounts_raw", name="PCA_raw")
umi_filtered <- runPCA(umi_filtered, exprs_values="logcpm", name="PCA_cpm") 
umi_filtered <- runPCA(umi_filtered, exprs_values="logcounts", name="PCA_scran")

# Create comparison plots
p1 <- plotPCA(umi_filtered, dimred="PCA_raw", colour_by="individual", shape_by="replicate") +
  ggtitle("A. Raw Log Counts\n(Depth-dependent)") + 
  theme_minimal() +
  theme(legend.position="none")

p2 <- plotPCA(umi_filtered, dimred="PCA_cpm", colour_by="individual", shape_by="replicate") +
  ggtitle("B. CPM Normalised\n(Better separation)") + 
  theme_minimal() +
  theme(legend.position="none")

p3 <- plotPCA(umi_filtered, dimred="PCA_scran", colour_by="individual", shape_by="replicate") +
  ggtitle("C. Scran Normalised\n(Optimal biological signal)") + 
  theme_minimal()

# Combine plots
combined <- plot_grid(
  p1, p2, p3,
  labels = c("A","B","C"),
  ncol   = 3,
  align  = "hv"
)
ggsave("pca_comparison.png", combined, width=12, height=4)
```




# PART 2: FEATURE SELECTION


```{r SCE, message=FALSE, warning=FALSE, fig.width=10, fig.height=5}

```

# Remove genes not expressed in any cell

Remove the genes that are not expressed in any cell. As you can see, earlier it had 19027 genes and now it has only 18,726 genes 

```{r}

```

# Cleaning the single cell experiment
ERCC spike-ins are synthetic RNA molecules added to samples to measure technical variation.
Defined control features(genes)- ERCC spike-ins and mitochondrial genes: https://jdblischak.github.io/singleCellSeq/analysis/ 

* Removing the genes that have ERCC on it. According to the results there are 89 ERCC coded   genes in the 18,726 genes related to this dataset, leaving 18,637 genes in total for this   dataset.



```{r exprs-qc4}

altExp(umi,"ERCC") <- umi[grep("^ERCC-",rownames(umi)), ]
ercc_count <- sum(grepl("^ERCC-", rownames(umi)))
print(ercc_count)
umi <- umi[grep("^ERCC-",rownames(umi),invert = T), ]
```

## Map ENSEMBL IDs to gene symbols

Now, let's map ENSEMBL IDs to gene symbols. From the `table` command, we can see that most genes were annotated; however, 846 returned "NA" from a total of 18,637. 

```{r exprs-qc4b}
gene_names <- mapIds(org.Hs.eg.db, keys=rownames(umi), keytype="ENSEMBL", columns="SYMBOL",column="SYMBOL")
gene_names[1:4]
rowData(umi)$SYMBOL <- gene_names
table(is.na(gene_names))
```

## Remove genes with no symbols

Let's remove all genes for which no symbols were found. This bring to a total of 17,803 genes for this dataset.

```{r}
umi <- umi[! is.na(rowData(umi)$SYMBOL),]
```

# Step 7: Identify mitochondrial genes 


* Once mitochondria dies, the debris can be mistaken for a cell. so therefore, need to remove the known mitochondrial cells. Mitochondrial reads often indicate dying or stressed cells.
 
 
* A high percentage of reads mapped to mitochondrial genes is a common QC filter.

Let's check if we can find mitochondrial proteins in the newly annotated symbols.

```{r}
grep("^MT-",rowData(umi)$SYMBOL,value = T)
```

Strangely, this returns nothing. Similar command to find ribosomal proteins (which start with RPL or RPS) works as expected, accounting 97 mitochondrial /ribosomal proteins present in the dataset sequenced.

```{r}
length(grep("^RP[LS]",rowData(umi)$SYMBOL,value = T))
```

Quick search for mitochondrial protein *ATP8*, which is also called *MT-ATP8*, shows that the name does not contain "MT-". However, the correct feature (ENSEMBL ID *ENSG00000228253*) is present in our annotation.

```{r}
grep("ATP8",rowData(umi)$SYMBOL,value = T)
```

Most modern annotations, e.g. ones used by `Cell Ranger`, will have mitochondrial genes names that start with *MT-*. For some reason, the one we have found does not. Annotation problems in general are very common and should be always considered carefully. In our case, we also can't find the location of genes since chromosomes are not supported in `org.Hs.eg.db` - there are no genome location columns in this database:

```{r}
columns(org.Hs.eg.db)
```


# Identify mitochondrial genes via EnsDb and examine them

Let's try a different, more detailed database - `EnsDb.Hsapiens.v86`. Using this resource, we can find 13 protein-coding genes located in the mitochondria:  

```{r exprs-qc5}
ensdb_genes <- genes(EnsDb.Hsapiens.v86)
MT_names <- ensdb_genes[seqnames(ensdb_genes) == "MT"]$gene_id
is_mito <- rownames(umi) %in% MT_names
table(is_mito)
```


### Basic QC

The following `scater` functions allow us to add per-cell and per-gene metrics useful for dataset evaluation. Most popular metrics per cell are total number of counts (UMIs), total number of detected genes, total number of mitochondrial counts, percent of mitochondrial counts, etc. 

perCellQCMetrics() calculates QC metrics on a per-cell basis, e.g., total counts, number of detected genes, percentage of reads mapping to mitochondrial genes (given by subsets=list(Mito=is_mito)). Hence perCellQCMetrics() calculates a variety of QC metrics for each cell (i.e., each column of SingleCellExperiment).

* Results of the perCellQCMetrics()

Rows (rownames): Each row corresponds to a single cell (e.g., NA19098.r1.A01). There are 864 cells in total (nrows = 864).

Columns (listData): Each column is a different per-cell QC metric. Key metrics include:

sum:
Total UMI (or read) count across all genes for that cell. Sometimes also called library size.
UMIs as Count Units: In scRNA-seq data, UMIs are used as counting units. They give a precise count of how many RNA molecules were detected for each gene, which helps in quantifying gene expression more accurately. This is what is often referred to in the sum column of dataframe, which aggregates the total UMIs for each cell.

detected:
Number of genes that have a non-zero count (i.e., how many genes were detected in that cell). The number of genes detected (in the detected column of dataframe) refers to how many different genes have at least one UMI associated with them in each cell. n scRNA-seq data, each gene is represented by the sum of reads or UMIs that map to it, which tells us how active the gene is in producing RNA in each cell. 

subsets_Mito_sum:
Total UMI count from the subset of genes identified as mitochondrial (based on is_mito).

subsets_Mito_detected:
Number of mitochondrial genes detected (i.e., those with non-zero count) in that cell.

subsets_Mito_percent:
Percentage of total counts in the cell that come from mitochondrial genes: subsets_Mito_sum/sum * 100%
High percentage here often indicates poor-quality or dying cells.

altexps_ERCC_sum:
Total UMI count corresponding to ERCC spike-ins (if available).

altexps_ERCC_detected:
Number of distinct ERCC transcripts detected.

altexps_ERCC_percent:
Percentage of total counts that are ERCC spike-ins.

total:
Combined total (e.g., endogenous genes + ERCC, depending on the scater function’s settings).

Overall, umi_cell helps you detect potentially low-quality cells (e.g., low sum, low detected, high subsets_Mito_percent) before filtering.

perFeatureQCMetrics() calculates metrics on a per-gene (feature) basis, e.g., the number of cells in which a gene is detected.

Rows (rownames): Each row corresponds to a single gene (identified by ENSEMBL IDs). Here there are 17,803 genes.

Columns (listData): Each column is a different gene-level metric:

mean:
The mean expression level for that gene across all cells (based on UMIs). Therefore, mean in umi_features is the average expression of the gene across all cells, measured in UMIs. This can give an idea of how broadly or narrowly expressed a gene is across the sampled cells.

detected:
The percentage (or sometimes absolute number) of cells in which that gene had a non-zero count.

For example, if detected = 84.26, that typically means ~84% of cells expressed this gene above the detection threshold.

# STEP8: Calculate Per-Cell and Per-Feature QC Metrics


```{r exprs-qc6}
umi_cell <- perCellQCMetrics(umi,subsets=list(Mito=is_mito))
umi_feature <- perFeatureQCMetrics(umi)
head(umi_cell)
head(umi_feature)
```

# Step 9: Add QC metrics into the SCE object

We can now use the functions that add the metrics calculated above to per-cell and per-gene metadata:

Expected Output:
The umi object now has new columns in colData(umi) like total, detected, subsets_Mito_percent.


```{r exprs-qc6b}
umi <- addPerCellQC(umi, subsets=list(Mito=is_mito))
umi <- addPerFeatureQC(umi)
```


# Step 10: Visual QC Checks (Histograms, Outlier Detection)

Manual filtering can use any cut-off we choose. In order to find a good value, it's good to look at the distribution:

```{r exprs-qc7}
hist(
    umi$total,
    breaks = 100
)
abline(v = 25000, col = "red")
```

```{r exprs-qc8}
hist(
  umi_cell$detected,
  breaks = 100
)
abline(v = 7000, col = "red")
```

Sometimes it's hard to come up with an obvious filtering cut-off. In this case, adaptive threshold can help us identify points that are more than 3 [median absolute deviations](https://en.wikipedia.org/wiki/Median_absolute_deviation) (MADs) away from the median in any of the variables we use for QC. 

Be careful to specify if the correct direction of the deviation: indeed, low number of detected genes, but high MT gene percentage, are hallmarks of a low quality cell:

```{r exprs-qc9}
qc.lib2 <- isOutlier(umi_cell$sum, log=TRUE, type="lower")
attr(qc.lib2, "thresholds")
qc.nexprs2 <- isOutlier(umi_cell$detected, log=TRUE, type="lower")
attr(qc.nexprs2, "thresholds")
qc.spike2 <- isOutlier(umi_cell$altexps_ERCC_percent, type="higher")
attr(qc.spike2, "thresholds")
qc.mito2 <- isOutlier(umi_cell$subsets_Mito_percent, type="higher")
attr(qc.mito2, "thresholds")
discard2 <- qc.lib2 | qc.nexprs2 | qc.spike2 | qc.mito2
DataFrame(LibSize=sum(qc.lib2), NExprs=sum(qc.nexprs2), SpikeProp=sum(qc.spike2), MitoProp=sum(qc.mito2), Total=sum(discard2))
```

# Step 11: Automate Outlier Detection

However, all the actions performed above could be done in one `scater` command, `quickPerCellQC`:

* quickPerCellQC Function: This function performs a quick and standardized quality control check on dataset, assessing cells based on several metrics like library size, number of features (genes) detected, mitochondrial gene content, and ERCC spike-in content.

sub.fields Parameter: We have specified two fields for particular attention—mitochondrial gene percentage and ERCC spike-in percentage. These are commonly used to identify potentially problematic cells due to cell stress/death (high mitochondrial content) or technical issues (high ERCC content).

Result interpretation:

low_lib_size: 47 cells have been flagged for having a low total number of UMIs. These cells likely had poor RNA capture or library preparation.

low_n_features: 65 cells have been identified with a low number of detected genes, indicating they might not represent the full transcriptomic complexity expected in healthy cells.

high_subsets_Mito_percent: 75 cells are flagged for having a high percentage of mitochondrial transcripts, suggesting they may be dying or under stress.

high_altexps_ERCC_percent: 139 cells have a high percentage of ERCC spike-ins, possibly indicating issues with spike-in normalisation or over-representation of technical artefacts.

discard: Based on the combination of these criteria, 194 cells in total have been flagged for exclusion from further analysis.

```{r exprs-qc10}
reasons <- quickPerCellQC(umi_cell, sub.fields=c("subsets_Mito_percent", "altexps_ERCC_percent"))
colSums(as.matrix(reasons))
```

Let's add another metadata column that would keep the information about whether a cell is discarded or not: 

Interpretation:

FALSE (670): Out of the total cells analysed, 670 cells passed all the QC checks and were not flagged for discarding.

TRUE (194): 194 cells did not meet the quality standards based on the specified criteria and are recommended to be excluded from downstream analyses.

```{r exprs-qc11}
umi$discard <- reasons$discard
table(umi$discard)
```

# Step 12: Explore Batch Effects


Plotting various coldata (cell-level medadata) assays against each other allows us to illustrate the dependencies between them. For example, cells with high mitochondrial content usually are considered dead or dying; these cells also usually have low overall UMI counts and number of detected genes. 

In each plots:
1. sum (x-axis) vs. subsets_Mito_percent (y-axis):

*Higher mito-percent typically indicates poor-quality cells: Many orange points (cells flagged for discarding) toward higher mitochondrial percentages.

*Low total UMI counts but relatively high mito-percent (which are marked as 'True' for discard). These cells are generally considered to be of lower quality, potentially due to being dead or dying, as mitochondrial gene expression is often higher in stressed cells.

*Blue points tend to form a “cloud” around lower mito-percent (often under 5–6%) and span a broad range of total UMIs. These cells are considered good quality.

* Interpretation:
The inverse relationship between total UMIs and mitochondrial content supports the common quality control criterion that cells with high mitochondrial content (usually above a threshold around 9%) should be discarded. This plot validates the threshold setting for discarding cells based on mitochondrial content, especially useful for filtering out potentially problematic cells that could skew downstream analysis.


2.  sum (x-axis) vs. detected (y-axis)

*Strong positive correlation: Cells with more total UMI counts also tend to have more detected genes—this is normal in scRNA-seq.

*Discarded cells (orange) generally cluster toward the lower end on both axes (i.e., fewer total counts and fewer detected genes).

*Retained cells (blue) form the main “cloud” with higher total counts and higher gene detection.


* Interpretation: 
The correlation highlights that as the amount of RNA (UMIs) increases, the diversity of detected genes also increases, which is expected in healthier or more actively transcribing cells. Cells failing to reach a minimal threshold of UMIs and gene detection are correctly flagged as low-quality, justifying their exclusion from further analyses.


3. altexps_ERCC_percent (x-axis) vs. subsets_Mito_percent (y-axis)

*Discarded cells often have either high ERCC percentages (far right orange cluster) or high mitochondrial percentages (upper orange cluster), or both.

*Kept cells (blue) mostly remain in a lower range for both ERCC percent and mito-percent.

Interpretation:
If a cell has a large fraction of spike-in (ERCC) reads, it often means the endogenous library is poor. Likewise, a high fraction of mitochondrial reads points to poor cell integrity. Both of these can trigger discarding.

```{r exprs-qc12}
plotColData(umi, x="sum", y="subsets_Mito_percent", colour_by="discard")
plotColData(umi, x="sum", y="detected", colour_by="discard")
plotColData(umi, x="altexps_ERCC_percent", y="subsets_Mito_percent",colour_by="discard")

```

We can also plot coldata with splitting by batches to see if there are substantial batch-specific differences: 

```{r exprs-qc13}
library(scales)
plotColData(umi, x="sum", y="detected", colour_by="discard", other_fields = "individual") + 
  facet_wrap(~individual) + scale_x_continuous(labels = unit_format(unit = "k", scale = 1e-3))
plotColData(umi, x="sum", y="detected", colour_by="discard", other_fields = "replicate") + 
  facet_wrap(~replicate)  + scale_x_continuous(labels = unit_format(unit = "k", scale = 1e-3))
```

### Highly Expressed Genes

Let's take a look at the most expressed genes in the whole dataset. We will use symbols we obtained above. Most of the genes we see are mitochondrial or ribosomal proteins, which is pretty typical for most scRNA-seq datasets. 

```{r exprs-qc14}
plotHighestExprs(umi, exprs_values = "counts", 
                 feature_names_to_plot = "SYMBOL", colour_cells_by="detected")
```

Let's keep the genes which were detected (expression value > 1) in 2 or more cells. We'll discard approximately 4,000 weakly expressed genes. 

```{r exprs-qc15}
keep_feature <- nexprs(umi,byrow = TRUE,detection_limit = 1) >= 2
rowData(umi)$discard <- ! keep_feature
table(rowData(umi)$discard)
``` 

Let's make a new assay, `logcounts_raw`, which will contain log2-transformed counts with added pseudocount of 1.

```{r exprs-qc16}
assay(umi, "logcounts_raw") <- log2(counts(umi) + 1)
```

Finally, let's save the `SingleCellExperiment` object with all the fields we have added to the per-cell metadata, and new assays (`logcounts_raw`):

```{r exprs-qc17}
saveRDS(umi, file = "/mnt/vol1/scRNA_playground/ScRNA_playground_data/Datasets/tung/umi.rds")
```


```{r exprs-qc17}
saveRDS(umi, file = "/mnt/vol1/scRNA_playground/ScRNA_playground_data/Datasets/tung/umi.rds")
```






### sessionInfo()


```{r echo=FALSE}
sessionInfo()
```

